# Algorithm
## :key: 복잡도

### :bulb: 시간 복잡도 : 얼마나 오래 걸리는지
1. O(1) 상수 시간 ex) 연산이 한번만 수행되는 상수연산
2. O(logN) 로그 시간 ex) 
3. O(N) 선형 시간 ex) N에 비례하는 연산 , 반복문
4. O(NlogN) 로그 선형 시간
5. O(N^2) 이차 시간 ex) N x N 2중 반복문
6. O(N^3) 삼차 시간 ex) 3중
7. O(2^n) 지수 시간

- 연산 횟수가 10억을 넘어가면 c기준 1초
### :bulb: 공간 복잡도 : 얼마나 많은 메모리를 차지 하는지
1. int a[1000] = 4KB
2. int a[1000000]=4MB
3. int a[2000][2000]=16MB

- 파이썬 기준 1초에 2000만번 수행함

## :pushpin: 그리디(탐욕법)

### :bulb: 가장 좋아 보이는 것만을 선택해서 문제를 풀 수 있는가?
( ex '가장 큰 순서대로' , '가장 작은 순서대로' )


## :pushpin: 구현

### :bulb: 완전탐색 : 모든 경우의 수를 다 계산
- 데이터가 100만개 이하일 때 사용하면 적절함
### :bulb: 시뮬레이션 : 알고리즘을 한 단계씩 차례대로


## :pushpin: DFS/BFS

### :bulb: DFS(Depth-First-Search) : 깊이 우선 탐색
- 노드와 간선으로 이루어진 그래프에서 깊은 부분을 우선적으로 탐색하는 알고리즘
- 스택 자료구조에 기초한다

### :bulb: BFS(Breadth-First-Search) : 너비 우선 탐색
- 노드와 간선으로 이루어진 그래프에서 가까운 노드부터 탐색하는 알고리즘
- 큐 자료구조를 이용한다
- 인접한 노드를 반복적으로 큐에 넣도록 알고리즘을 작성하면 자연스럽게 먼저 들어온 것이 먼저 나가게 되어 가까운 노드부터 탐색을 진행하게 된다.


## :pushpin: 정렬

### :bulb: 선택정렬 : '매번 가장 작은 것을 선택한다'는 의미의 원시적 알고리즘
### :bulb: 삽입정렬 : 각 데이터를 확인하여 적절한 위치에 삽입하는 알고리즘
- 삽입 정렬은 두 번째 데이터부터 시작한다
- 데이터가 거의 정렬되어 있을 때 훨씬 효율적이다.
- O(N^2)의 시간 복잡도를 가진다

### :bulb: 퀵정렬 : 기준 데이터를 설정, 그 기준 큰 데이터와 작은 데이터를 바꾸는 알고리즘
- 피벗이라는 기준이 사용 된다.
- 리스트의 첫번째 데이터가 피벗이 된다.
- 리스트의 왼쪽부터 피벗보다 큰 데이터를 찾고, 오른쪽부터 피벗보다 작은 데이터를 찾는다
- O(NlogN)의 시간 복잡도를 가진다

### :bulb: 계수정렬 : 특정 조건이 부합할 때만 사용할 수 있는 알고리즘. 매우 빠르다
- 데이터 크기 범위가 제한되어 정수 형태로 표현할 수 있을 때만 사용할 수 있다.
- 데이터 크기 차이가 100만이 넘지 않을때 효과적이다.
- 모든 범위를 담을 수 있는 리스트를 선언해야 한다.
- O(N+K)의 공간복잡도를 가진다.


## :pushpin: 이진 탐색
- 배열 내부의 데이터가 정렬되어야만 사용 가능하다.
- 시작점, 끝점, 중간점의 변수를 사용하여 중간점에 위치한 데이터를 반복적으로 비교한다.
